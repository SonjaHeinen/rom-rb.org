<!DOCTYPE html><html><head><link href="/images/favicon.png" rel="icon" type="image/png" /><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="ROM &raquo; Guides &raquo; Repositories via @rom_rb" name="twitter:description" /><meta content="ROM &raquo; Guides &raquo; Repositories" name="description" /><title>ROM &raquo; Guides &raquo; Repositories</title><style type="text/css">.highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #d0d0d0;
  background-color: #151515;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}</style><link href="../../../stylesheets/all.css" rel="stylesheet" /><script src="../../../javascripts/all.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script><script>$(function() {
  var share = new Share(".share")
});
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-2573270-5', 'auto');
ga('send', 'pageview');</script></head><body class="guides guides_basics guides_basics_repositories guides_basics_repositories_index"><div class="page-wrapper"><header><nav class="navbar navbar-default navbar-static-top"><div class="navbar-inner"><div class="container"><a class="navbar-brand" href="/">Ruby Object Mapper</a><ul class="nav navbar-nav"><li class=""><a class="" href="/introduction">Introduction</a></li><li class=""><a class="" href="/guides">Guides</a></li><li class=""><a class="" href="/tutorials">Tutorials</a></li><li class="dropdown"><a class="dropdown-toggle" role="button" data-toggle="dropdown" href="#">API <span class='caret'/></a><ul class="dropdown-menu" role="menu"><li><a href="http://www.rubydoc.info/gems/rom">rom</a></li><li><a href="http://www.rubydoc.info/gems/rom-sql">rom-sql</a></li><li><a href="http://www.rubydoc.info/gems/rom-yesql">rom-yesql</a></li><li><a href="http://www.rubydoc.info/gems/rom-influxdb">rom-influxdb</a></li><li><a href="http://www.rubydoc.info/gems/rom-event_store">rom-event_store</a></li><li><a href="http://www.rubydoc.info/gems/rom-rethinkdb">rom-rethinkdb</a></li><li><a href="http://www.rubydoc.info/gems/rom-mongo">rom-mongo</a></li><li><a href="http://www.rubydoc.info/gems/rom-redis">rom-redis</a></li><li><a href="http://www.rubydoc.info/gems/rom-csv">rom-csv</a></li><li><a href="http://www.rubydoc.info/gems/rom-yaml">rom-yaml</a></li><li><a href="http://www.rubydoc.info/gems/rom-dm">rom-dm</a></li><li><a href="http://www.rubydoc.info/gems/rom-lotus">rom-lotus</a></li><li><a href="http://www.rubydoc.info/gems/rom-rails">rom-rails</a></li><li><a href="http://www.rubydoc.info/gems/rom-roda">rom-roda</a></li></ul></li><li class=""><a class="" href="/blog">Blog</a></li><li class=""><a class="" href="/contribute">Contribute</a></li><li class=""><a class="" href="/status">Status</a></li><li class=""><a class="" href="/backers">Backers <3</a></li></ul></div></div></nav></header><div class="container"><div class="content"><div class="row"><div class="col-md-3"><ul class="nav nav-pills nav-stacked"><li class="nav-heading"><a class="nav-heading" href="/guides/basics/setup">Setup</a></li><li class="nav-heading active"><a class="nav-heading active" href="/guides/basics/repositories">Repositories</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/relations">Relations</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/commands">Commands</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/mappers">Mappers</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/adapters">Adapters</a></li><li class=""><a class="" href="/guides/adapters/how-to">How-to</a></li><li class=""><a class="" href="/guides/adapters/sql">SQL</a></li><li class=""><a class="" href="/guides/adapters/cassandra">Cassandra</a></li></ul></div><div class="col-md-9"><div class="page-article"><h1 id="repositories">Repositories</h1>

<p>In ROM, repositories encapsulate access to domain-specific entities. They use
<a href="/guides/basics/relations/">relations</a> to expose a convenient interface for
composing relations and automatically mapping them to struct objects.</p>

<h2 id="installation">Installation</h2>

<p>Repository is a seperate gem:</p>
<pre class="highlight plaintext"><code>gem install rom-repository
</code></pre>

<h2 id="defining-a-repository-class">Defining a Repository Class</h2>

<p>A repository object gets access to selected relations that are available in the
ROM container object. When you create a repository class you can explicitly define
which relations should be established:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserRepository</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">relations</span> <span class="ss">:users</span>

  <span class="c1"># your methods go here</span>
<span class="k">end</span>

<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span><span class="p">.</span><span class="nf">env</span>

<span class="n">user_repo</span> <span class="o">=</span> <span class="no">UserRepository</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">rom</span><span class="p">)</span>

<span class="n">user_repo</span><span class="p">.</span><span class="nf">users</span>
</code></pre>

<p>Once you have access to your relations you can expose access to specific entities
with your custom interface:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserRepository</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">relations</span> <span class="ss">:users</span>

  <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">users</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="nb">id</span><span class="p">).</span><span class="nf">one!</span>
  <span class="k">end</span>
<span class="k">end</span>


<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span><span class="p">.</span><span class="nf">env</span>

<span class="n">user_repo</span> <span class="o">=</span> <span class="no">UserRepository</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">rom</span><span class="p">)</span>

<span class="n">user_repo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># #&lt;ROM::Struct[User] id=1 name="Jane"&gt;</span>
</code></pre>

<p>As you can see, the repository automatically maps relation tuples to instances of
<code>ROM::Struct</code>.</p>

<h2 id="rom-structs">ROM Structs</h2>

<p>ROM structs are simple data-capsules. They give you access to their values via
attribute <code>[]</code> readers and are coercible to a hash. With powerful relation query
DSLs, you can easily compose relations and return data in the expected state.
That&rsquo;s why automatically mapping to small structs is feasible and no custom
mapping is required.</p>

<p>Struct constructor is strict with regards to the attribute hash it receives - if
there are attributes that were not expected you will get an exception.</p>

<p>Here&rsquo;s an example of a struct:</p>
<pre class="highlight ruby"><code><span class="n">user</span> <span class="o">=</span> <span class="n">user_repo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># #&lt;ROM::Struct[User] id=1 name="Jane"&gt;</span>

<span class="n">user</span><span class="p">.</span><span class="nf">id</span> <span class="c1"># 1</span>
<span class="n">user</span><span class="p">[</span><span class="ss">:id</span><span class="p">]</span> <span class="c1"># 1</span>

<span class="n">user</span><span class="p">.</span><span class="nf">to_hash</span> <span class="c1"># {:id=&gt;1, :name=&gt;"Jane"}</span>
</code></pre>

<p>ROM repositories generate struct classes for you, so that you don&rsquo;t have to define
them.</p>

<div class="well">
There&rsquo;s a planned feature with which you&rsquo;ll be able to provide namespaces for your
structs, this will define struct class constants rather than using anonymous classes.
</div>

<h2 id="working-with-relations">Working With Relations</h2>

<p>In ROM, relations represent specific database queries that your application needs
to execute to get its data. It is recommended that you define explicit relation
classes to achieve better encapsulation and simplify composition.</p>

<p>A common pattern is to encapsulate specific relation methods and use those in your
repositories rather than accessing lower-level query DSLs.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">listing</span>
    <span class="nb">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:created_at</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:id</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">registered_after</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
    <span class="n">where</span> <span class="p">{</span> <span class="n">created_at</span> <span class="o">&gt;</span> <span class="n">timestamp</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">UserRepository</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">relations</span> <span class="ss">:users</span>

  <span class="k">def</span> <span class="nf">new_users</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
    <span class="n">users</span><span class="p">.</span><span class="nf">listing</span><span class="p">.</span><span class="nf">registered_after</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">user_repo</span><span class="p">.</span><span class="nf">new_users</span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2015</span><span class="p">))</span>
</code></pre>

<p>This way, you encapsulate specific queries and domain-specific relation views.
Your application interfaces with simple structs and has no idea how they are
fetched and instantiated.</p>

<h2 id="relation-views">Relation Views</h2>

<p>Every method that you define in a relation represents a specific relation <strong>view</strong>.
For views that you re-use, to compose more complex relations, you can explicitly
define their structure with the view plugin</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">view</span><span class="p">(</span><span class="ss">:listing</span><span class="p">,</span> <span class="p">[</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:created_at</span><span class="p">])</span> <span class="k">do</span>
    <span class="nb">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:created_at</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:id</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">registered_after</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
    <span class="n">where</span> <span class="p">{</span> <span class="n">created_at</span> <span class="o">&gt;</span> <span class="n">timestamp</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Thanks to this feature we can be explicit about the data structures our relations
return, this comes with the benefit of auto-mapping and better introspection
capabilities that can be used to build even more advanced features.</p>

<div class="well">
The view feature will be enhanced with type annotations so that it will be possible
to automatically map database-specific types into domain-specific types.
</div>

<h3 id="base-view-plugin">Base View Plugin</h3>

<p>ROM repository provides an SQL relation plugin called base_view, this defines
a base relation view for you which, by default, includes all the column names and
orders by the primary key in descending order:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>
    <span class="n">base</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<h2 id="composing-relations">Composing Relations</h2>

<p>Every repository can access multiple relations. Thanks to this you can compose
them however you want and get aggregates back. There&rsquo;s no need
to define associations with complicated configuration logic, you simply define
methods on your repository objects:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserRepository</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">relations</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:tasks</span>

  <span class="k">def</span> <span class="nf">with_tasks</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">users</span><span class="p">.</span><span class="nf">by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">combine_children</span><span class="p">(</span><span class="ss">many: </span><span class="n">tasks</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">user_repo</span><span class="p">.</span><span class="nf">with_tasks</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [#&lt;ROM::Struct[User] id=1 name="Jane" tasks=[#&lt;ROM::Struct[Task] id=2 user_id=1 title="Jane Task"&gt;]&gt;, #&lt;ROM::Struct[User] id=2 name="Joe" tasks=[#&lt;ROM::Struct[Task] id=1 user_id=2 title="Joe Task"&gt;]&gt;]</span>
</code></pre>

<p>What you see here is an example usage of <code>auto_combine</code> plugin.</p>

<h3 id="composition-plugins">Composition Plugins</h3>

<p>ROM Repository is built on top of lower-level relation interface of ROM. It ships
with a couple of plugins that are simple syntactic sugar using Relation <code>combine</code>
interface under the hood.</p>

<p>The beauty of this approach is that even the most complex scenarios are handled by
the very same composition interface. There&rsquo;s nothing special going on here, we&rsquo;re
simply using relations and their views. When default behavior is not satisfactory,
you can define your own relation view, improve the query yourself and it will work
exactly the same in terms of the internal machanics.</p>

<div class="well">
Notice that you can compose relations from different databases!
</div>

<h4 id="auto-combine-plugin">Auto-Combine Plugin</h4>

<p>The &lsquo;auto_combine` plugin adds 3 convenient methods for composing relations into
a graph which is automatically mapped to aggregate structs:</p>

<ul>
<li><code>#combine_parents</code> automatically joins parents using eager-loading</li>
<li><code>#combine_children</code> automatically joins children using eager-loading</li>
<li><code>#combine</code> can accept a simple hash defining what other relations should be joined
it is used by the <code>combine_parents</code> and <code>combine_children</code> and is useful when
your relations don&rsquo;t have conventional foreign-key names</li>
</ul>

<p>Here are a couple of examples how to combine child relations:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserRepository</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">relations</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:tasks</span>

  <span class="k">def</span> <span class="nf">with_tasks</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">users</span><span class="p">.</span><span class="nf">by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">combine_children</span><span class="p">(</span><span class="ss">many: </span><span class="n">tasks</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">with_recent_tasks</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">users</span><span class="p">.</span><span class="nf">by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">combine_children</span><span class="p">(</span><span class="ss">many: </span><span class="n">tasks</span><span class="p">.</span><span class="nf">recent</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">with_top_priority_task</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">users</span><span class="p">.</span><span class="nf">by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">combine_children</span><span class="p">(</span><span class="ss">one: </span><span class="n">tasks</span><span class="p">.</span><span class="nf">top_priority</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Here are a couple of examples how to combine parent relations:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">TaskRepository</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">relations</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:tasks</span>

  <span class="k">def</span> <span class="nf">with_user</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">tasks</span><span class="p">.</span><span class="nf">by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">combine_parents</span><span class="p">(</span><span class="ss">one: </span><span class="n">users</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">with_owner</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">tasks</span><span class="p">.</span><span class="nf">by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">combine_parents</span><span class="p">(</span><span class="ss">one: </span><span class="p">{</span> <span class="ss">owner: </span><span class="n">users</span> <span class="p">})</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>You can mix it however you want and combine both child and parent relations:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">TaskRepository</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">relations</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:tasks</span><span class="p">,</span> <span class="ss">:tags</span>

  <span class="k">def</span> <span class="nf">with_owner_and_tags</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">tasks</span>
      <span class="p">.</span><span class="nf">by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">combine_parents</span><span class="p">(</span><span class="ss">one: </span><span class="p">{</span> <span class="ss">owner: </span><span class="n">users</span> <span class="p">})</span>
      <span class="p">.</span><span class="nf">combine_children</span><span class="p">(</span><span class="ss">tags: </span><span class="n">tags</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>You can override default <code>combine</code> logic by simply implementing your own view:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Tags</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">view</span><span class="p">(</span><span class="ss">:for_tasks</span><span class="p">,</span> <span class="p">[</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:task_id</span><span class="p">])</span> <span class="k">do</span> <span class="o">|</span><span class="n">tasks</span><span class="o">|</span>
    <span class="c1"># do whatever you want</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">TaskRepository</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">relations</span> <span class="ss">:tasks</span><span class="p">,</span> <span class="ss">:tags</span>

  <span class="k">def</span> <span class="nf">with_tags</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="c1"># now your own `for_tasks` will be called</span>
    <span class="n">tasks</span><span class="p">.</span><span class="nf">by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">combine_children</span><span class="p">(</span><span class="ss">tags: </span><span class="n">tags</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<h4 id="auto-wrap-plugin">Auto-Wrap Plugin</h4>

<p>ROM allows you to map joined relations to aggregates too. This is done via <code>wrap</code>
operation and repository interface gives you a convenience method which does what
you need:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">TagsRepository</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">relations</span> <span class="ss">:tasks</span><span class="p">,</span> <span class="ss">:tags</span>

  <span class="k">def</span> <span class="nf">with_task</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">tags</span><span class="p">.</span><span class="nf">by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">wrap_parent</span><span class="p">(</span><span class="ss">task: </span><span class="n">tasks</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>The result is exactly the same as if you used <code>combine_parents</code> with the exception
of the query logic - in case of wrapping we are using an inner join.</p>

<p>If the default query isn&rsquo;t doing what you want you can override it:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Tags</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">for_wrap</span><span class="p">(</span><span class="n">join_keys</span><span class="p">,</span> <span class="n">parent_relation_name</span><span class="p">)</span>
    <span class="c1"># do what you want</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<div class="page-article-edit"><hr /><div class="share pull-left"></div><p class="pull-right">Edit this article on <a href="https://github.com/rom-rb/rom-rb.org/tree/master/source/doc-pages/guides/basics/repositories.md">GitHub</a></p></div></div></div></div></div></div></div><footer><div class="container"><div class="social"><div class="github"><iframe allowtransparency="true" frameborder="0" height="20" scrolling="0" src="http://ghbtns.com/github-btn.html?user=rom-rb&repo=rom&type=watch&count=true" width="110"></iframe></div><div class="twitter"><a class="twitter-follow-button" data-show-count="true" data-show-screen-name="false" href="https://twitter.com/rom_rb">Follow</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></div></div><div class="muted copyright">Ruby Object Mapper &copy; 2014-2015</div></div></footer></body></html>